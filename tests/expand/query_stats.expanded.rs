use serde::Deserialize as _;
pub struct QueryStat {
    pub database_id: i64,
    pub collected_at: SystemTime,
    pub collected_secs: i64,
    pub fingerprint: i64,
    pub postgres_role_id: i64,
    pub calls: i64,
    pub rows: i64,
    pub total_time: f64,
    pub io_time: f64,
    pub shared_blks_hit: i64,
    pub shared_blks_read: i64,
}
/// Generated by pco_store to store and load compressed versions of [QueryStat]
pub struct CompressedQueryStats {
    filter: Option<Filter>,
    database_id: i64,
    collected_at: Vec<u8>,
    collected_secs: Vec<u8>,
    fingerprint: Vec<u8>,
    postgres_role_id: Vec<u8>,
    calls: Vec<u8>,
    rows: Vec<u8>,
    total_time: Vec<u8>,
    io_time: Vec<u8>,
    shared_blks_hit: Vec<u8>,
    shared_blks_read: Vec<u8>,
}
impl CompressedQueryStats {
    /// Loads data for the specified filters.
    pub async fn load(
        db: &impl ::std::ops::Deref<Target = deadpool_postgres::ClientWrapper>,
        mut filter: Filter,
        fields: impl TryInto<Fields>,
    ) -> anyhow::Result<Vec<CompressedQueryStats>> {
        let mut fields = fields
            .try_into()
            .map_err(|_| anyhow::Error::msg("unknown field"))?;
        fields.merge_filter(&filter);
        if filter.database_id.is_empty() {
            return Err(anyhow::Error::msg("database_id".to_string() + " is required"));
        }
        if filter.collected_at.is_none() {
            return Err(anyhow::Error::msg("collected_at".to_string() + " is required"));
        }
        filter.range_truncate()?;
        let sql = "SELECT ".to_string() + fields.select().as_str() + " FROM "
            + "query_stats" + " WHERE "
            + "database_id = ANY($1) AND end_at >= $2 AND start_at <= $3";
        let mut results = Vec::new();
        for row in db
            .query(
                &db.prepare_cached(&sql).await?,
                &[
                    &filter.database_id,
                    filter.collected_at.as_ref().unwrap().start(),
                    filter.collected_at.as_ref().unwrap().end(),
                ],
            )
            .await?
        {
            results.push(fields.load_from_row(row, Some(filter.clone()))?);
        }
        Ok(results)
    }
    /// Deletes data for the specified filters, returning it to the caller.
    ///
    /// Note that all rows are returned from [decompress][Self::decompress] even if post-decompress filters would normally apply.
    pub async fn delete(
        db: &impl ::std::ops::Deref<Target = deadpool_postgres::ClientWrapper>,
        mut filter: Filter,
        fields: impl TryInto<Fields>,
    ) -> anyhow::Result<Vec<CompressedQueryStats>> {
        let mut fields = fields
            .try_into()
            .map_err(|_| anyhow::Error::msg("unknown field"))?;
        fields.merge_filter(&filter);
        if filter.database_id.is_empty() {
            return Err(anyhow::Error::msg("database_id".to_string() + " is required"));
        }
        if filter.collected_at.is_none() {
            return Err(anyhow::Error::msg("collected_at".to_string() + " is required"));
        }
        filter.range_truncate()?;
        let sql = "DELETE FROM ".to_string() + "query_stats" + " WHERE "
            + "database_id = ANY($1) AND end_at >= $2 AND start_at <= $3" + " RETURNING "
            + fields.select().as_str();
        let mut results = Vec::new();
        for row in db
            .query(
                &db.prepare_cached(&sql).await?,
                &[
                    &filter.database_id,
                    filter.collected_at.as_ref().unwrap().start(),
                    filter.collected_at.as_ref().unwrap().end(),
                ],
            )
            .await?
        {
            results.push(fields.load_from_row(row, None)?);
        }
        Ok(results)
    }
    /// Decompresses a group of data points.
    pub fn decompress(self) -> anyhow::Result<Vec<QueryStat>> {
        let mut results = Vec::new();
        let collected_at: Vec<u64> = if self.collected_at.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.collected_at)?
        };
        let collected_secs: Vec<i64> = if self.collected_secs.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.collected_secs)?
        };
        let fingerprint: Vec<i64> = if self.fingerprint.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.fingerprint)?
        };
        let postgres_role_id: Vec<i64> = if self.postgres_role_id.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.postgres_role_id)?
        };
        let calls: Vec<i64> = if self.calls.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.calls)?
        };
        let rows: Vec<i64> = if self.rows.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.rows)?
        };
        let total_time: Vec<f64> = if self.total_time.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.total_time)?
        };
        let io_time: Vec<f64> = if self.io_time.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.io_time)?
        };
        let shared_blks_hit: Vec<i64> = if self.shared_blks_hit.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.shared_blks_hit)?
        };
        let shared_blks_read: Vec<i64> = if self.shared_blks_read.is_empty() {
            Vec::new()
        } else {
            ::pco::standalone::simple_decompress(&self.shared_blks_read)?
        };
        let len = [
            collected_at.len(),
            collected_secs.len(),
            fingerprint.len(),
            postgres_role_id.len(),
            calls.len(),
            rows.len(),
            total_time.len(),
            io_time.len(),
            shared_blks_hit.len(),
            shared_blks_read.len(),
        ]
            .into_iter()
            .max()
            .unwrap_or(0);
        for index in 0..len {
            let row = QueryStat {
                database_id: self.database_id,
                collected_at: std::time::SystemTime::UNIX_EPOCH
                    + std::time::Duration::from_micros(collected_at[index]),
                collected_secs: collected_secs.get(index).cloned().unwrap_or_default(),
                fingerprint: fingerprint.get(index).cloned().unwrap_or_default(),
                postgres_role_id: postgres_role_id
                    .get(index)
                    .cloned()
                    .unwrap_or_default(),
                calls: calls.get(index).cloned().unwrap_or_default(),
                rows: rows.get(index).cloned().unwrap_or_default(),
                total_time: total_time.get(index).cloned().unwrap_or_default(),
                io_time: io_time.get(index).cloned().unwrap_or_default(),
                shared_blks_hit: shared_blks_hit.get(index).cloned().unwrap_or_default(),
                shared_blks_read: shared_blks_read
                    .get(index)
                    .cloned()
                    .unwrap_or_default(),
            };
            if self.filter.as_ref().map(|f| f.filter(&row)) != Some(false) {
                results.push(row);
            }
        }
        Ok(results)
    }
    /// Writes the data to disk.
    pub async fn store(
        db: &impl ::std::ops::Deref<Target = deadpool_postgres::ClientWrapper>,
        rows: Vec<QueryStat>,
    ) -> anyhow::Result<()> {
        if rows.is_empty() {
            return Ok(());
        }
        let mut grouped_rows: ahash::AHashMap<_, Vec<QueryStat>> = ahash::AHashMap::new();
        for row in rows {
            grouped_rows.entry((row.database_id,)).or_default().push(row);
        }
        let sql = "COPY query_stats (database_id, start_at, end_at, collected_at, collected_secs, fingerprint, postgres_role_id, calls, rows, total_time, io_time, shared_blks_hit, shared_blks_read) FROM STDIN BINARY";
        let types = &[
            tokio_postgres::types::Type::INT8,
            tokio_postgres::types::Type::TIMESTAMPTZ,
            tokio_postgres::types::Type::TIMESTAMPTZ,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
        ];
        let stmt = db.copy_in(&db.prepare_cached(&sql).await?).await?;
        let writer = tokio_postgres::binary_copy::BinaryCopyInWriter::new(stmt, types);
        let mut writer = writer;
        #[allow(unused_mut)]
        let mut writer = unsafe {
            ::pin_utils::core_reexport::pin::Pin::new_unchecked(&mut writer)
        };
        for rows in grouped_rows.into_values() {
            let collected_at: Vec<_> = rows.iter().map(|s| s.collected_at).collect();
            let start_at = *collected_at.iter().min().unwrap();
            let end_at = *collected_at.iter().max().unwrap();
            let collected_at: Vec<u64> = collected_at
                .into_iter()
                .map(|t| {
                    t
                        .duration_since(std::time::SystemTime::UNIX_EPOCH)
                        .unwrap()
                        .as_micros() as u64
                })
                .collect();
            writer
                .as_mut()
                .write(
                    &[
                        &rows[0].database_id,
                        &start_at,
                        &end_at,
                        &::pco::standalone::simpler_compress(
                                &collected_at,
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.collected_secs).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.fingerprint).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows
                                    .iter()
                                    .map(|r| r.postgres_role_id)
                                    .collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.calls).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.rows).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.total_time).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.io_time).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.shared_blks_hit).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows
                                    .iter()
                                    .map(|r| r.shared_blks_read)
                                    .collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                    ],
                )
                .await?;
        }
        writer.finish().await?;
        Ok(())
    }
    /// Writes the data to disk, with the provided grouping closure applied.
    ///
    /// This can be used to improve the compression ratio and reduce read IO, for example
    /// by compacting real-time data into a single row per hour / day / week.
    pub async fn store_grouped<F, R>(
        db: &impl ::std::ops::Deref<Target = deadpool_postgres::ClientWrapper>,
        rows: Vec<QueryStat>,
        grouping: F,
    ) -> anyhow::Result<()>
    where
        F: Fn(&QueryStat) -> R,
        R: Eq + std::hash::Hash,
    {
        if rows.is_empty() {
            return Ok(());
        }
        let mut grouped_rows: ahash::AHashMap<_, Vec<QueryStat>> = ahash::AHashMap::new();
        for row in rows {
            grouped_rows.entry((row.database_id, grouping(&row))).or_default().push(row);
        }
        let sql = "COPY query_stats (database_id, start_at, end_at, collected_at, collected_secs, fingerprint, postgres_role_id, calls, rows, total_time, io_time, shared_blks_hit, shared_blks_read) FROM STDIN BINARY";
        let types = &[
            tokio_postgres::types::Type::INT8,
            tokio_postgres::types::Type::TIMESTAMPTZ,
            tokio_postgres::types::Type::TIMESTAMPTZ,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
            tokio_postgres::types::Type::BYTEA,
        ];
        let stmt = db.copy_in(&db.prepare_cached(&sql).await?).await?;
        let writer = tokio_postgres::binary_copy::BinaryCopyInWriter::new(stmt, types);
        let mut writer = writer;
        #[allow(unused_mut)]
        let mut writer = unsafe {
            ::pin_utils::core_reexport::pin::Pin::new_unchecked(&mut writer)
        };
        for rows in grouped_rows.into_values() {
            let collected_at: Vec<_> = rows.iter().map(|s| s.collected_at).collect();
            let start_at = *collected_at.iter().min().unwrap();
            let end_at = *collected_at.iter().max().unwrap();
            let collected_at: Vec<u64> = collected_at
                .into_iter()
                .map(|t| {
                    t
                        .duration_since(std::time::SystemTime::UNIX_EPOCH)
                        .unwrap()
                        .as_micros() as u64
                })
                .collect();
            writer
                .as_mut()
                .write(
                    &[
                        &rows[0].database_id,
                        &start_at,
                        &end_at,
                        &::pco::standalone::simpler_compress(
                                &collected_at,
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.collected_secs).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.fingerprint).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows
                                    .iter()
                                    .map(|r| r.postgres_role_id)
                                    .collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.calls).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.rows).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.total_time).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.io_time).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows.iter().map(|r| r.shared_blks_hit).collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                        &::pco::standalone::simpler_compress(
                                &rows
                                    .iter()
                                    .map(|r| r.shared_blks_read)
                                    .collect::<Vec<_>>(),
                                ::pco::DEFAULT_COMPRESSION_LEVEL,
                            )
                            .unwrap(),
                    ],
                )
                .await?;
        }
        writer.finish().await?;
        Ok(())
    }
}
#[serde(deny_unknown_fields)]
/// Generated by pco_store to specify filters when loading [QueryStat]
pub struct Filter {
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub database_id: Vec<i64>,
    #[serde(deserialize_with = "deserialize_time_range")]
    pub collected_at: Option<std::ops::RangeInclusive<SystemTime>>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub collected_secs: Vec<i64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub fingerprint: Vec<i64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub postgres_role_id: Vec<i64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub calls: Vec<i64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub rows: Vec<i64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub total_time: Vec<f64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub io_time: Vec<f64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub shared_blks_hit: Vec<i64>,
    #[serde(default)]
    #[serde_as(deserialize_as = "serde_with::DefaultOnNull<serde_with::OneOrMany<_>>")]
    #[serde(
        deserialize_with = ":: serde_with :: As :: < serde_with :: DefaultOnNull < serde_with :: OneOrMany\n< :: serde_with :: Same > > > :: deserialize"
    )]
    pub shared_blks_read: Vec<i64>,
}
#[automatically_derived]
impl ::core::fmt::Debug for Filter {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "database_id",
            "collected_at",
            "collected_secs",
            "fingerprint",
            "postgres_role_id",
            "calls",
            "rows",
            "total_time",
            "io_time",
            "shared_blks_hit",
            "shared_blks_read",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.database_id,
            &self.collected_at,
            &self.collected_secs,
            &self.fingerprint,
            &self.postgres_role_id,
            &self.calls,
            &self.rows,
            &self.total_time,
            &self.io_time,
            &self.shared_blks_hit,
            &&self.shared_blks_read,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(f, "Filter", names, values)
    }
}
#[automatically_derived]
impl ::core::default::Default for Filter {
    #[inline]
    fn default() -> Filter {
        Filter {
            database_id: ::core::default::Default::default(),
            collected_at: ::core::default::Default::default(),
            collected_secs: ::core::default::Default::default(),
            fingerprint: ::core::default::Default::default(),
            postgres_role_id: ::core::default::Default::default(),
            calls: ::core::default::Default::default(),
            rows: ::core::default::Default::default(),
            total_time: ::core::default::Default::default(),
            io_time: ::core::default::Default::default(),
            shared_blks_hit: ::core::default::Default::default(),
            shared_blks_read: ::core::default::Default::default(),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Filter {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private228::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private228::Ok(__Field::__field0),
                        1u64 => _serde::__private228::Ok(__Field::__field1),
                        2u64 => _serde::__private228::Ok(__Field::__field2),
                        3u64 => _serde::__private228::Ok(__Field::__field3),
                        4u64 => _serde::__private228::Ok(__Field::__field4),
                        5u64 => _serde::__private228::Ok(__Field::__field5),
                        6u64 => _serde::__private228::Ok(__Field::__field6),
                        7u64 => _serde::__private228::Ok(__Field::__field7),
                        8u64 => _serde::__private228::Ok(__Field::__field8),
                        9u64 => _serde::__private228::Ok(__Field::__field9),
                        10u64 => _serde::__private228::Ok(__Field::__field10),
                        _ => {
                            _serde::__private228::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 11",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "database_id" => _serde::__private228::Ok(__Field::__field0),
                        "collected_at" => _serde::__private228::Ok(__Field::__field1),
                        "collected_secs" => _serde::__private228::Ok(__Field::__field2),
                        "fingerprint" => _serde::__private228::Ok(__Field::__field3),
                        "postgres_role_id" => _serde::__private228::Ok(__Field::__field4),
                        "calls" => _serde::__private228::Ok(__Field::__field5),
                        "rows" => _serde::__private228::Ok(__Field::__field6),
                        "total_time" => _serde::__private228::Ok(__Field::__field7),
                        "io_time" => _serde::__private228::Ok(__Field::__field8),
                        "shared_blks_hit" => _serde::__private228::Ok(__Field::__field9),
                        "shared_blks_read" => {
                            _serde::__private228::Ok(__Field::__field10)
                        }
                        _ => {
                            _serde::__private228::Err(
                                _serde::de::Error::unknown_field(__value, FIELDS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private228::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"database_id" => _serde::__private228::Ok(__Field::__field0),
                        b"collected_at" => _serde::__private228::Ok(__Field::__field1),
                        b"collected_secs" => _serde::__private228::Ok(__Field::__field2),
                        b"fingerprint" => _serde::__private228::Ok(__Field::__field3),
                        b"postgres_role_id" => {
                            _serde::__private228::Ok(__Field::__field4)
                        }
                        b"calls" => _serde::__private228::Ok(__Field::__field5),
                        b"rows" => _serde::__private228::Ok(__Field::__field6),
                        b"total_time" => _serde::__private228::Ok(__Field::__field7),
                        b"io_time" => _serde::__private228::Ok(__Field::__field8),
                        b"shared_blks_hit" => _serde::__private228::Ok(__Field::__field9),
                        b"shared_blks_read" => {
                            _serde::__private228::Ok(__Field::__field10)
                        }
                        _ => {
                            let __value = &_serde::__private228::from_utf8_lossy(
                                __value,
                            );
                            _serde::__private228::Err(
                                _serde::de::Error::unknown_field(__value, FIELDS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private228::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private228::PhantomData<Filter>,
                lifetime: _serde::__private228::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Filter;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private228::Formatter,
                ) -> _serde::__private228::fmt::Result {
                    _serde::__private228::Formatter::write_str(
                        __formatter,
                        "struct Filter",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field1 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Option<std::ops::RangeInclusive<SystemTime>>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: deserialize_time_range(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Filter with 11 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field3 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field4 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field5 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field6 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field7 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<f64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field8 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<f64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field9 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field10 = match {
                        #[doc(hidden)]
                        struct __DeserializeWith<'de> {
                            value: Vec<i64>,
                            phantom: _serde::__private228::PhantomData<Filter>,
                            lifetime: _serde::__private228::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private228::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::__private228::Ok(__DeserializeWith {
                                    value: ::serde_with::As::<
                                        serde_with::DefaultOnNull<
                                            serde_with::OneOrMany<::serde_with::Same>,
                                        >,
                                    >::deserialize(__deserializer)?,
                                    phantom: _serde::__private228::PhantomData,
                                    lifetime: _serde::__private228::PhantomData,
                                })
                            }
                        }
                        _serde::__private228::Option::map(
                            _serde::de::SeqAccess::next_element::<
                                __DeserializeWith<'de>,
                            >(&mut __seq)?,
                            |__wrap| __wrap.value,
                        )
                    } {
                        _serde::__private228::Some(__value) => __value,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    _serde::__private228::Ok(Filter {
                        database_id: __field0,
                        collected_at: __field1,
                        collected_secs: __field2,
                        fingerprint: __field3,
                        postgres_role_id: __field4,
                        calls: __field5,
                        rows: __field6,
                        total_time: __field7,
                        io_time: __field8,
                        shared_blks_hit: __field9,
                        shared_blks_read: __field10,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private228::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field1: _serde::__private228::Option<
                        Option<std::ops::RangeInclusive<SystemTime>>,
                    > = _serde::__private228::None;
                    let mut __field2: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field3: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field4: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field5: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field6: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field7: _serde::__private228::Option<Vec<f64>> = _serde::__private228::None;
                    let mut __field8: _serde::__private228::Option<Vec<f64>> = _serde::__private228::None;
                    let mut __field9: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    let mut __field10: _serde::__private228::Option<Vec<i64>> = _serde::__private228::None;
                    while let _serde::__private228::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private228::Option::is_some(&__field0) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "database_id",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field1 => {
                                if _serde::__private228::Option::is_some(&__field1) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "collected_at",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Option<std::ops::RangeInclusive<SystemTime>>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: deserialize_time_range(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field2 => {
                                if _serde::__private228::Option::is_some(&__field2) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "collected_secs",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field3 => {
                                if _serde::__private228::Option::is_some(&__field3) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "fingerprint",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field4 => {
                                if _serde::__private228::Option::is_some(&__field4) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "postgres_role_id",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field5 => {
                                if _serde::__private228::Option::is_some(&__field5) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("calls"),
                                    );
                                }
                                __field5 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field6 => {
                                if _serde::__private228::Option::is_some(&__field6) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("rows"),
                                    );
                                }
                                __field6 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field7 => {
                                if _serde::__private228::Option::is_some(&__field7) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "total_time",
                                        ),
                                    );
                                }
                                __field7 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<f64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field8 => {
                                if _serde::__private228::Option::is_some(&__field8) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "io_time",
                                        ),
                                    );
                                }
                                __field8 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<f64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field9 => {
                                if _serde::__private228::Option::is_some(&__field9) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "shared_blks_hit",
                                        ),
                                    );
                                }
                                __field9 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                            __Field::__field10 => {
                                if _serde::__private228::Option::is_some(&__field10) {
                                    return _serde::__private228::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "shared_blks_read",
                                        ),
                                    );
                                }
                                __field10 = _serde::__private228::Some({
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<i64>,
                                        phantom: _serde::__private228::PhantomData<Filter>,
                                        lifetime: _serde::__private228::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private228::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private228::Ok(__DeserializeWith {
                                                value: ::serde_with::As::<
                                                    serde_with::DefaultOnNull<
                                                        serde_with::OneOrMany<::serde_with::Same>,
                                                    >,
                                                >::deserialize(__deserializer)?,
                                                phantom: _serde::__private228::PhantomData,
                                                lifetime: _serde::__private228::PhantomData,
                                            })
                                        }
                                    }
                                    match _serde::de::MapAccess::next_value::<
                                        __DeserializeWith<'de>,
                                    >(&mut __map) {
                                        _serde::__private228::Ok(__wrapper) => __wrapper.value,
                                        _serde::__private228::Err(__err) => {
                                            return _serde::__private228::Err(__err);
                                        }
                                    }
                                });
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private228::Some(__field0) => __field0,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private228::Some(__field1) => __field1,
                        _serde::__private228::None => {
                            return _serde::__private228::Err(
                                <__A::Error as _serde::de::Error>::missing_field(
                                    "collected_at",
                                ),
                            );
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private228::Some(__field2) => __field2,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private228::Some(__field3) => __field3,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private228::Some(__field4) => __field4,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private228::Some(__field5) => __field5,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::__private228::Some(__field6) => __field6,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field7 = match __field7 {
                        _serde::__private228::Some(__field7) => __field7,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field8 = match __field8 {
                        _serde::__private228::Some(__field8) => __field8,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field9 = match __field9 {
                        _serde::__private228::Some(__field9) => __field9,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    let __field10 = match __field10 {
                        _serde::__private228::Some(__field10) => __field10,
                        _serde::__private228::None => {
                            _serde::__private228::Default::default()
                        }
                    };
                    _serde::__private228::Ok(Filter {
                        database_id: __field0,
                        collected_at: __field1,
                        collected_secs: __field2,
                        fingerprint: __field3,
                        postgres_role_id: __field4,
                        calls: __field5,
                        rows: __field6,
                        total_time: __field7,
                        io_time: __field8,
                        shared_blks_hit: __field9,
                        shared_blks_read: __field10,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "database_id",
                "collected_at",
                "collected_secs",
                "fingerprint",
                "postgres_role_id",
                "calls",
                "rows",
                "total_time",
                "io_time",
                "shared_blks_hit",
                "shared_blks_read",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Filter",
                FIELDS,
                __Visitor {
                    marker: _serde::__private228::PhantomData::<Filter>,
                    lifetime: _serde::__private228::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::clone::Clone for Filter {
    #[inline]
    fn clone(&self) -> Filter {
        Filter {
            database_id: ::core::clone::Clone::clone(&self.database_id),
            collected_at: ::core::clone::Clone::clone(&self.collected_at),
            collected_secs: ::core::clone::Clone::clone(&self.collected_secs),
            fingerprint: ::core::clone::Clone::clone(&self.fingerprint),
            postgres_role_id: ::core::clone::Clone::clone(&self.postgres_role_id),
            calls: ::core::clone::Clone::clone(&self.calls),
            rows: ::core::clone::Clone::clone(&self.rows),
            total_time: ::core::clone::Clone::clone(&self.total_time),
            io_time: ::core::clone::Clone::clone(&self.io_time),
            shared_blks_hit: ::core::clone::Clone::clone(&self.shared_blks_hit),
            shared_blks_read: ::core::clone::Clone::clone(&self.shared_blks_read),
        }
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Filter {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Filter {
    #[inline]
    fn eq(&self, other: &Filter) -> bool {
        self.database_id == other.database_id && self.collected_at == other.collected_at
            && self.collected_secs == other.collected_secs
            && self.fingerprint == other.fingerprint
            && self.postgres_role_id == other.postgres_role_id
            && self.calls == other.calls && self.rows == other.rows
            && self.total_time == other.total_time && self.io_time == other.io_time
            && self.shared_blks_hit == other.shared_blks_hit
            && self.shared_blks_read == other.shared_blks_read
    }
}
impl Filter {
    /// Builds new filter with the required fields defined by `group_by` and `timestamp`
    pub fn new(
        database_id: &[i64],
        collected_at: std::ops::RangeInclusive<SystemTime>,
    ) -> Self {
        Self {
            database_id: database_id.into(),
            collected_at: Some(collected_at),
            ..Self::default()
        }
    }
    fn filter(&self, row: &QueryStat) -> bool {
        (self.database_id.is_empty() || self.database_id.contains(&row.database_id))
            && self.collected_at.as_ref().map(|t| t.contains(&row.collected_at))
                != Some(false)
            && (self.collected_secs.is_empty()
                || self.collected_secs.contains(&row.collected_secs))
            && (self.fingerprint.is_empty()
                || self.fingerprint.contains(&row.fingerprint))
            && (self.postgres_role_id.is_empty()
                || self.postgres_role_id.contains(&row.postgres_role_id))
            && (self.calls.is_empty() || self.calls.contains(&row.calls))
            && (self.rows.is_empty() || self.rows.contains(&row.rows))
            && (self.total_time.is_empty() || self.total_time.contains(&row.total_time))
            && (self.io_time.is_empty() || self.io_time.contains(&row.io_time))
            && (self.shared_blks_hit.is_empty()
                || self.shared_blks_hit.contains(&row.shared_blks_hit))
            && (self.shared_blks_read.is_empty()
                || self.shared_blks_read.contains(&row.shared_blks_read))
    }
    /// Convenience function to unwrap the timestamp range lower and upper bounds
    pub fn range_bounds(&self) -> anyhow::Result<(SystemTime, SystemTime)> {
        use anyhow::Context;
        let timestamp = self.collected_at.clone().context("no timestamp")?;
        Ok((*timestamp.start(), *timestamp.end()))
    }
    /// Convenience function to return the amount of time the filter covers
    pub fn range_duration(&self) -> anyhow::Result<std::time::Duration> {
        let (start, end) = self.range_bounds()?;
        Ok(end.duration_since(start)?)
    }
    /// Shifts the filtered time range. This for example makes it easier
    /// to perform two queries: once for "today", and one for "today, 7 days ago".
    /// In that example the second query would do `filter.shift(Duration::days(-7))`
    pub fn range_shift(&mut self, duration: std::time::Duration) -> anyhow::Result<()> {
        use std::ops::Add;
        let (start, end) = self.range_bounds()?;
        self.collected_at = Some(start.add(duration)..=end.add(duration));
        Ok(())
    }
    /// Postgres doesn't support nanosecond precision and nor does MacOS, so this
    /// truncates nanosecond precision for timestamp comparisons
    fn range_truncate(&mut self) -> anyhow::Result<()> {
        let (start, end) = self.range_bounds()?;
        self.collected_at = Some(
            Self::truncate_nanos(start)?..=Self::truncate_nanos(end)?,
        );
        Ok(())
    }
    fn truncate_nanos(time: SystemTime) -> anyhow::Result<SystemTime> {
        use anyhow::Context;
        use std::time::{UNIX_EPOCH, Duration};
        let duration = time.duration_since(UNIX_EPOCH).context("earlier than epoch")?;
        let micros = duration.as_secs() * 1_000_000
            + (duration.subsec_nanos() / 1_000) as u64;
        Ok(
            UNIX_EPOCH + Duration::from_secs(micros / 1_000_000)
                + Duration::from_micros(micros % 1_000_000),
        )
    }
}
/// Generated by pco_store to choose which fields to decompress when loading [QueryStat]
pub struct Fields {
    database_id: bool,
    collected_at: bool,
    collected_secs: bool,
    fingerprint: bool,
    postgres_role_id: bool,
    calls: bool,
    rows: bool,
    total_time: bool,
    io_time: bool,
    shared_blks_hit: bool,
    shared_blks_read: bool,
}
#[automatically_derived]
#[doc(hidden)]
unsafe impl ::core::clone::TrivialClone for Fields {}
#[automatically_derived]
impl ::core::clone::Clone for Fields {
    #[inline]
    fn clone(&self) -> Fields {
        let _: ::core::clone::AssertParamIsClone<bool>;
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for Fields {}
#[automatically_derived]
impl ::core::fmt::Debug for Fields {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "database_id",
            "collected_at",
            "collected_secs",
            "fingerprint",
            "postgres_role_id",
            "calls",
            "rows",
            "total_time",
            "io_time",
            "shared_blks_hit",
            "shared_blks_read",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.database_id,
            &self.collected_at,
            &self.collected_secs,
            &self.fingerprint,
            &self.postgres_role_id,
            &self.calls,
            &self.rows,
            &self.total_time,
            &self.io_time,
            &self.shared_blks_hit,
            &&self.shared_blks_read,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(f, "Fields", names, values)
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Fields {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Fields {
    #[inline]
    fn eq(&self, other: &Fields) -> bool {
        self.database_id == other.database_id && self.collected_at == other.collected_at
            && self.collected_secs == other.collected_secs
            && self.fingerprint == other.fingerprint
            && self.postgres_role_id == other.postgres_role_id
            && self.calls == other.calls && self.rows == other.rows
            && self.total_time == other.total_time && self.io_time == other.io_time
            && self.shared_blks_hit == other.shared_blks_hit
            && self.shared_blks_read == other.shared_blks_read
    }
}
impl Fields {
    pub fn new(fields: &[&str]) -> anyhow::Result<Self> {
        fields.try_into().map_err(|e| anyhow::Error::msg(e))
    }
    pub fn required() -> Self {
        Self {
            database_id: true,
            collected_at: true,
            collected_secs: false,
            fingerprint: false,
            postgres_role_id: false,
            calls: false,
            rows: false,
            total_time: false,
            io_time: false,
            shared_blks_hit: false,
            shared_blks_read: false,
        }
    }
    fn merge_filter(&mut self, filter: &Filter) {
        (!filter.collected_secs.is_empty()).then(|| self.collected_secs = true);
        (!filter.fingerprint.is_empty()).then(|| self.fingerprint = true);
        (!filter.postgres_role_id.is_empty()).then(|| self.postgres_role_id = true);
        (!filter.calls.is_empty()).then(|| self.calls = true);
        (!filter.rows.is_empty()).then(|| self.rows = true);
        (!filter.total_time.is_empty()).then(|| self.total_time = true);
        (!filter.io_time.is_empty()).then(|| self.io_time = true);
        (!filter.shared_blks_hit.is_empty()).then(|| self.shared_blks_hit = true);
        (!filter.shared_blks_read.is_empty()).then(|| self.shared_blks_read = true);
    }
    fn select(&self) -> String {
        let mut fields = Vec::new();
        self.database_id.then(|| fields.push("database_id"));
        self.collected_at.then(|| fields.push("collected_at"));
        self.collected_secs.then(|| fields.push("collected_secs"));
        self.fingerprint.then(|| fields.push("fingerprint"));
        self.postgres_role_id.then(|| fields.push("postgres_role_id"));
        self.calls.then(|| fields.push("calls"));
        self.rows.then(|| fields.push("rows"));
        self.total_time.then(|| fields.push("total_time"));
        self.io_time.then(|| fields.push("io_time"));
        self.shared_blks_hit.then(|| fields.push("shared_blks_hit"));
        self.shared_blks_read.then(|| fields.push("shared_blks_read"));
        fields.join(", ")
    }
    fn load_from_row(
        &self,
        row: tokio_postgres::Row,
        filter: Option<Filter>,
    ) -> anyhow::Result<CompressedQueryStats> {
        let mut index = 0;
        Ok(CompressedQueryStats {
            filter,
            database_id: if self.database_id {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            collected_at: if self.collected_at {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            collected_secs: if self.collected_secs {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            fingerprint: if self.fingerprint {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            postgres_role_id: if self.postgres_role_id {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            calls: if self.calls {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            rows: if self.rows {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            total_time: if self.total_time {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            io_time: if self.io_time {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            shared_blks_hit: if self.shared_blks_hit {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
            shared_blks_read: if self.shared_blks_read {
                let v = row.get(index);
                index += 1;
                v
            } else {
                Default::default()
            },
        })
    }
}
impl Default for Fields {
    fn default() -> Self {
        Self {
            database_id: true,
            collected_at: true,
            collected_secs: true,
            fingerprint: true,
            postgres_role_id: true,
            calls: true,
            rows: true,
            total_time: true,
            io_time: true,
            shared_blks_hit: true,
            shared_blks_read: true,
        }
    }
}
impl TryFrom<&[&str]> for Fields {
    type Error = &'static str;
    fn try_from(input: &[&str]) -> Result<Self, Self::Error> {
        let mut fields = Self::required();
        for s in input {
            match *s {
                "database_id" => fields.database_id = true,
                "collected_at" => fields.collected_at = true,
                "collected_secs" => fields.collected_secs = true,
                "fingerprint" => fields.fingerprint = true,
                "postgres_role_id" => fields.postgres_role_id = true,
                "calls" => fields.calls = true,
                "rows" => fields.rows = true,
                "total_time" => fields.total_time = true,
                "io_time" => fields.io_time = true,
                "shared_blks_hit" => fields.shared_blks_hit = true,
                "shared_blks_read" => fields.shared_blks_read = true,
                _ => return Err("unknown field"),
            }
        }
        Ok(fields)
    }
}
impl<const N: usize> TryFrom<&[&str; N]> for Fields {
    type Error = &'static str;
    fn try_from(input: &[&str; N]) -> Result<Self, Self::Error> {
        Self::try_from(&input[..])
    }
}
impl TryFrom<Vec<String>> for Fields {
    type Error = &'static str;
    fn try_from(input: Vec<String>) -> Result<Self, Self::Error> {
        let input: Vec<_> = input.iter().map(|s| s.as_str()).collect();
        Self::try_from(input.as_slice())
    }
}
impl From<()> for Fields {
    fn from(_: ()) -> Self {
        Self::default()
    }
}
impl<'de> serde::Deserialize<'de> for Fields {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(FieldsVisitor)
    }
}
struct FieldsVisitor;
impl<'de> serde::de::Visitor<'de> for FieldsVisitor {
    type Value = Fields;
    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("an array of strings matching the struct fields")
    }
    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        let mut fields = Vec::new();
        while let Some(field) = seq.next_element()? {
            fields.push(field);
        }
        Fields::try_from(fields).map_err(serde::de::Error::custom)
    }
    fn visit_unit<E>(self) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        Ok(Fields::default())
    }
}
/// Deserializes many different time range formats:
/// - an array with two strings becomes a normal time range: ["a", "b"] -> a..=b
/// - an array with one string becomes a single-value time range: ["a"] -> a..=a
/// - a string literal becomes a single-value time range:           "a" -> a..=a
fn deserialize_time_range<'de, D>(
    deserializer: D,
) -> Result<Option<std::ops::RangeInclusive<SystemTime>>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    Ok(TimeRange::deserialize(deserializer)?.0)
}
struct TimeRange(Option<std::ops::RangeInclusive<SystemTime>>);
#[automatically_derived]
impl ::core::fmt::Debug for TimeRange {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "TimeRange", &&self.0)
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for TimeRange {}
#[automatically_derived]
impl ::core::cmp::PartialEq for TimeRange {
    #[inline]
    fn eq(&self, other: &TimeRange) -> bool {
        self.0 == other.0
    }
}
impl<'de> serde::Deserialize<'de> for TimeRange {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(TimeRangeVisitor)
    }
}
struct TimeRangeVisitor;
impl<'de> serde::de::Visitor<'de> for TimeRangeVisitor {
    type Value = TimeRange;
    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a single time string or an array with 1-2 time strings")
    }
    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        if value.is_empty() {
            return Ok(TimeRange(None));
        }
        match serde::Deserialize::deserialize(
            serde::de::value::StrDeserializer::<E>::new(value),
        ) {
            Ok(start) => Ok(TimeRange(Some(start..=start))),
            Err(err) => {
                Err(
                    E::custom(
                        "invalid time format: ".to_string() + err.to_string().as_str(),
                    ),
                )
            }
        }
    }
    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        let start = match seq.next_element::<Option<SystemTime>>()? {
            Some(Some(time)) => time,
            Some(None) | None => return Ok(TimeRange(None)),
        };
        let end = match seq.next_element::<Option<SystemTime>>()? {
            Some(Some(time)) => time,
            Some(None) | None => start,
        };
        Ok(TimeRange(Some(start..=end)))
    }
    fn visit_unit<E>(self) -> Result<Self::Value, E>
    where
        E: serde::de::Error,
    {
        Ok(TimeRange(None))
    }
}
